int count = 0;
	
	public void parseTokens()
	{
		String out = "";
		while(count < tokens.size())
		{
			String tkn = tokens.get(count);
			//String lxm = lexemes.get(ctr);
			if(tkn.equals("TAGIDENT"))
			{
				out += tagOpen();
				
			}
			count++;
		}
		
		System.out.println(out);
	}
	
	String tagOpen()
	{
		String concatenated = "";
		while(!tokens.get(count).equals("ENDTAGHEAD"))
		{
			if(tokens.get(count).equals("TAGIDENT"))
			{
				count++;
				concatenated += tagOpen();
			}
			else
			{
				concatenated += parse();
			}
		}
		return concatenated;
	}

String parse()
	{
		String concatenated = "";
		while(!tokens.get(count).equals("ENDTAGHEAD"))
		{
			if(tokens.get(count).equals("IDENT"))
			{
				concatenated += lexemes.get(count);
			}
			if(tokens.get(count).equals("NUMBER"))
			{
				concatenated += lexemes.get(count);
			}
			count++;
		}
		return concatenated;
	}
	
float result = Float.parseFloat(operlexeme.get(0));
	
	while(true)
	{
		int selector = 0;
		if(index.size() == max)
			break;
		for(String x : opertokens)
		{
			int indexer = -1;
			switch(selector)
			{
			case 0:
				if(x.equals("EXP"))
				{
					indexer = opertokens.indexOf(x);
					index.add(indexer);
				}
				break;
			case 1:
				if(x.equals("MODULUS"))
				{
					indexer = opertokens.indexOf(x);
					index.add(indexer);
				}
				break;
			case 2:
				if(x.equals("MULT"))
				{
					indexer = opertokens.indexOf(x);
					index.add(indexer);
				}
				break;
			case 3:
				if(x.equals("DIV"))
				{
					indexer = opertokens.indexOf(x);
					index.add(indexer);
				}
				break;
			case 4:
				if(x.equals("PLUS"))
				{
					indexer = opertokens.indexOf(x);
					index.add(indexer);
				}
				break;
			case 5:
				if(x.equals("MINUS"))
				{
					indexer = opertokens.indexOf(x);
					index.add(indexer);
				}
				else
				{
					index.add(-1);
				}
				break;
			}
				
		}
		selector++;
	}
	
	for(Integer i : index)
	{
		switch(opertokens.get(i))
		{
		case "MULT":
			result = 
			break;
		case "DIV":
			break;
		case "PLUS":
			break;
		case "MINUS":
			break;
		}
	}
	
EXPRESSION -> TERM {(plus | minus) TERM}
TERM -> FACTOR {(multiply | divide) FACTOR}
FACTOR -> number | lparen, EXPRESSION, rparen

void calaculate()
{
	float result = 0;
	if(NUMBER)
	{
		result = operate(number);
	}
	
	if(op)
	{
	}
}

void operate(number)
{
	
}

/* To be placed inside calculate supposedly unless I'm able to fix it
if(tokens.get(count).equals("NUMBER"))
{
	if(result == 0)
		result = Float.parseFloat(lexemes.get(count));
	switch(op)
	{
	case 0:
		break;
	case 1:
		result += Float.parseFloat(lexemes.get(count));
		break;
	case 2:
		result -= Float.parseFloat(lexemes.get(count));
		break;
	case 3:
		result *= Float.parseFloat(lexemes.get(count));
		break;
	case 4:
		result /= Float.parseFloat(lexemes.get(count));
		break;
	case 5:
		float multiplier = result;
		for(int ctr = 1; ctr < Integer.parseInt(lexemes.get(count)); ctr++)
			result *= multiplier;
		break;
	}
	op = 0;
}
switch(tokens.get(count))
{
case "PLUS":
	op = 1;
	break;
case "MINUS":
	op = 2;
	break;
case "MULT":
	op = 3;
	break;
case "DIV":
	op = 4;
	break;
case "EXP":
	op = 5;
	break;
}*/